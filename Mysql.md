

# 关系型数据库介绍

```shell
关系型数据库相当于一个目录，这个目录是存放数据的库。库里存放表，相当于文件。
```

# Oracle数据库应用范围

```shell
大公司、政府、金融
```

# Mysql数据库应用范围

```shell
互联网企业
```

# Mysql和Orale的区别

```http
凯叔表权提佩安
```



```shell
①，Oracle闭源、收费，Mysql开源、免费。

②，Oracle大型数据库、Mysql中小型数据库。

③，Oracle有表空间概念、Mysql没有。

④，Oracle可设置用户权限、访问权限、读写权限等，Mysql没有。

⑤，Oracle需要用户手动提交、Mysql默认自动提交。

⑥，Oracle全面、完整、稳定，对硬件要求高；Mysql使用cup和内存少，性能高。

⑦，Oracle使用许多安全功能，如用户名，密码，配置文件，本地身份证，外部身份验证，高级安全增强功能。Mysql使用三个参数来验证用户，即用户名、密码、位置；数据库认证上Mysql比Oracle认证更加容易。 
```

# Mysql和MariaDB区别

```shell
MariaDB数据库管理系统是Mysql的一个分支，目的是完全兼容Mysql，能够成为Mysql的代替品，运行速度更快。
```

# 关系型数据库与非关系型数据库的区别

```shell
①，关系型数据库
关系型数据库相当于一个目录，这个目录是存放数据的库。库里存放表，相当于文件。

优点：
1、遵循四大事务(原子性、一致性、隔离性、持续性)
2、支持sql语句，可用于表结构的复杂查询。

缺点：
1、读写性能差，海量的数据压力大
2、高并发性能差，传统关系型数据库而言，硬盘I/O是很大的瓶颈
3、固定表结构，灵活度稍欠                
Mysql是常用的关系型数据库。

②，非关系型数据库(Nosql、作为关系型数据库的补充)
非关系型数据是一种数据结构化存储方法的集合，可以是文档或者键值对等

优点：
1、灵活性：存储数据格式灵活可以是key,value形式、文档形式、图片形式等等，使用也灵活，应用场景广泛
2、高性能、速度快：nosql使用硬盘和内存，关系型数据库只能使用硬盘
3、高扩展性
4、成本低：开源

缺：
1、无标准查询语言、不提供sql支持
2、无事务处理能力
3、数据结构相对复杂，复杂查询方面稍欠
Redis是常用的非关系型数据库，且可持久化数据。

③，Mysql数据存储在磁盘中，redis数据存储在磁盘和内存中读写速度快。

④，Mysql端口号：3306、redis端口号：6379
```

# 数据库存储引      擎(扩展)

```shell
①，数据库存储引擎

存储引擎是数据库底层软件组织，数据库管理系统(DBMS)使用存储引擎进行创建、查询、更新、删除数据。

②，innodb

支持事务，支持行锁定，对事务的完整性要求比较高(银行)，要求实现并发控制(售票)，适用于频繁更新，删除操作数据库。

③，myisam：较高的查询速度，不支持事务。

④，mermory：读写速度快，安全性不高，对表的大小有要求，支持锁表不支持行锁定。
```

# 事务要符合四个条件(ACID)

```shell
原子性：事务要么成功，要么撤回，不会结束到中间某个环节。

一致性：数据库以及事务永远保持一致性，数据库的完整性不被破坏，即写入的数据必须符合预设的规则。

隔离性：多个事务同时对数据库的数据进行修改时，事务与事务之间存在隔离性。你干你的，我干我的。

持续性：数据会永久存储在永久存储器里
```

# 数据类型

```shell
整型(int)：作用:用户年龄、游戏等级、经验值

浮点数类型(float)：作用:用户身高、体重、薪水

定点数类型：作用: 货币等精度高的数据

字符串类型

#(char)固定字符串0~255、长度是固定的，插入数据的长度小于char的固定长度时，则用空格填充。

#(varchar)可变长度字符串0~65535、长度是可变的，插入的数据是多长，就按多长来存储。

#结合性能角度（char更快），节省磁盘空间角度（varchar更小），经常变化的字段用varchar，超过255字符的只能用varchar或者text

枚举类型enum：二选其一

日期类型：(year、date、time、datetime、datestamp) 

作用：储存用户注册时间、文章发布时间、文章更新时间、员工入职时间
```

# 完整备份

```shell
#备份完整的数据库数据

#优点：备份与恢复操作简单方便，恢复时一次恢复到位，恢复速度快

#缺点：占用空间大，备份速度慢
```

# 增量备份

```shell
#备份上一次备份到现在产生的新数据

#优点：数据量小，占用空间小，备份速度快

#缺点：恢复时间长，如中间某次的备份数据损坏，将导致数据的丢失
```

# 差异备份

```shell
#只备份跟完整备份不一样的数据，占用空间会比增量备份大

#恢复速度介于完整备份和增量备份之间
```

# 物理备份

```shell
#热备 #冷备 #温备
```

# 备份方式

```shell
#每周一次完整备份，平时每天增量备份

#日志生命周期：前三十天热备，30-60天温备，60-90天冷备，超过=90天扔掉
```

# Mysql优化

```shell
安全方面：修改默认端口号，禁止root用户远程登录，对用户降权，以普通用户运行mysql

性能方面：升级硬件，内存、磁盘、优化sql语句（开启慢查询）、设置索引

参数变化：innodb的buffer参数调大，连接数调大、缓存的参数优化

架构方面：读写分离，一主多从，高可用、mysql的约束添加
```

# 主从复制原理

```shell
主机打开binlog日志，，从机通过io进程读取主机的binlog日志，并将其记录到从库的中继日志里面，sql线程读取中继日志，同步到自己的数据库，实现主从复制。
```

# 主从复制问题如何解决

```shell
1、查看error日志，排错

2、slave库，show slave status\G 定位io或sql线程

解决故障

#停止从同步

#跳过一个事务(跳出出错的一步)

#重新开启同步，查看同步状态

如果还不行，就将问题库名的数据，从主库导出，导入从库后，重新主从

配合keepalived做高可用
```

# 主从复制数据不一致如何解决

```shell
问题原因

①人为误操作在从节点写入数据造成主从binlog节点不同步

②mysql版本不一致，个别语法执行不成功，5.7可以创建用户并授权，8.0必须先创建用户才能授权

解决方法：先停止主从复制，跳过当前事务，再开启主从同步，手动创建用户并授权，保证主从数据一致

问题原因

③主节点允许传送的数据最大是10M，从节点允许传送的数据最大是5M，如果一个7M的数据发送，主节点成功，从节点失败，导致主从数据不一致

解决方法：在mysql配置文件中设置max_allowed_packet（允许的最大数据包）的大小，这也是mysql优化的其中一项
```

# 异步复制

```shell
MySQL默认的复制即是异步的，主库在执行完客户端提交的事务后会立即将结果返给给客户端，并不关心从库是否已经接收并处理。
```

# 同步复制

```shell
指当主库执行完一个事务，所有的从库都执行了该事务才返回给客户端。因为需要等待所有从库执行完该事务才能返回，所以全同步复制的性能必然会收到严重的影响。
```

# 半同步复制

```shell
是介于同步复制与异步复制之间的一种，主库只需要等待至少一个从库节点收到并反馈事务即可，主库不需要等待所有从库给主库反馈。同时，这里只是一个收到的反馈，而不是已经完全完成并且提交的反馈，如此，节省了很多时间。
```

# 脏读

```shell
脏读就是修改一个数据，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据、
```

# 幻读

```shell
第一个事务对表中的数据进行了修改，修改表中的全部数据行。第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样
```

# 不可重复读

```shell
是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。因此称为是不可重复读 
```

# SQL定义了事务隔离级别分为四种

```shell
RR读未提交：可能出现脏读、不可重复读和幻读。

RC读已提交：可以避免脏读，但可能出现不可重复读和幻读。

RR可重复读：可以避免脏读和不可重复读，但可能出现幻读

SERIALIZABLE可串行化：可以避免脏读、不可重复读和幻读，但是并发性极低，一般很少使用。

##注意：隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大。

RU:就好比还没确定的消息，你却先知道了发布出去，最后又变更了，就是说瞎话了。常说的脏读，读到了还未提交的。

RC:只能读取到已经提交的事务。

RR:幻读。读到已提交的数据。

串行化：事务顺序执行，没有并行，完全杜绝幻读。

系统默认RR
```

# 数据库的一致性

```shell
就是多个节点中数据的值是一致的

强一致性：写入数据后，立马能读到最新的数据。

弱一致性：写入成功后，不承诺能立马读到最新的值，但在一定时间后能读到。
```

# Sql语句执行慢的原因

```http
########################
```



```
SQL语句执行慢主要有以下几个原因：

1. 数据库索引不合理：在大规模数据量时，没有使用合适的索引可能导致数据库需要进行全表扫描来检索数据，从而导致查询效率低下。

2. 查询语句没有加上合理的条件限制：若查询没有加上合理的条件限制，会导致数据库需要检索大量数据，导致查询效率降低。

3. 数据库表结构设计不合理：若表的设计不合理，会导致一些查询效率降低，甚至导致死锁等问题。

4. SQL语句中存在子查询以及多表Join操作：在某些情况下，随着子查询内数据量的增大和表的Join次数增加，查询效率也会大大降低。

5. 数据库服务器硬件性能低下：如果数据库服务器的硬件性能较差，如内存较小、I/O速度慢等，也会影响到SQL语句的查询效率。

针对上述问题，可以采用以下措施进行优化：

1. 优化索引：建立或更新索引，以加快SQL语句的执行效率。

2. 添加合理的条件限制：对查询语句加上合理的条件限制，以减少需要扫描的数据量，提高查询效率。

3. 合理优化表结构：优化表结构，减少Join操作，合理分配内存空间等。

4. 减少子查询和Join操作的使用：在开发中尽量避免使用子查询和Join操作，或者使用其他替代方案。

5. 提升服务器硬件性能：在满足需求的情况下，提升服务器硬件性能，以提高数据库系统的整体性能。

总之，SQL语句执行慢的问题需要综合考虑多种因素，并根据优化需求具体情况进行优化。
```



```shell
①硬件问题，I/O吞吐量小，磁盘空间满了等

②没有索引或索引失效

③数据过多

④服务器调优及各个参数设置（调整my.cnf）

⑤网络延迟
```

# mysql有几种备份方式？

```shell
逻辑备份和物理备份
逻辑备份：mysqldump工具备份
物理备份：完整备份、增量备份、差异备份
```

# mysql脏数据是什么概念？

```shell
脏数据（Dirty Read）是指源系统中的数据不在给定的范围内或对于实际业务毫无意义，或是数据格式非法，以及在源系统中存在不规范的编码和含糊的业务逻辑。
```

# mysql主从复制的方式有几种？

```shell
mysql主从复制是一种可用于提高系统可用性和读写分离的技术，常用的方式有以下几种：

1、基于二进制日志的复制（statement-based replication，sbr）
在这种方式下，主库上所有的修改操作都会记录在二进制日志中，然后将二进制日志传到从库并且应用到从库数据库中。但这种方式可能会存在一些不确定的问题，在某些情况下，可能不能完美地复制数据。

2、基于行的复制（row-based replication，rbr）
在这种方式下，当主库发生变化时，只会将主库已经修改的行发送到从库进行同步。并且可以对ddl进行完美支持，数据变更粒度更细，占用的带宽也少，但是二进制日志文件较大，空间开销比较大。

3、混合式复制（mixed-based replication，mbr）
在这种方式下，mysql会同时运用基于语句和基于行两种复制方式。

4、gtid复制（gtid replication）
全局事务标识符(gtid)是指在整个架构中单独的事务id，在主从复制场景中，主从的gtid是全局唯一的标识符。在使用gtid的情况下，我们不需要像以前那样使用file name and position来指定位置，而是直接使用gtid。

总之，主从复制方式的选择取决于你需要哪种类型的一致性和性能以及业务需求。
```

# 监控mysql都监控什么，都是怎么做的？

# mysql1T内存
