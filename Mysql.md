# 关系型数据库介绍

```shell
关系型数据库相当于一个目录，这个目录是存放数据的库。库里存放表，相当于文件。
```

# Oracle数据库应用范围

```shell
大公司、政府、金融
```

# Mysql数据库应用范围

```shell
互联网企业
```

# Mysql和Orale的区别

```http
凯叔表权提佩安
```



```shell
①，Oracle闭源、收费，Mysql开源、免费。

②，Oracle大型数据库、Mysql中小型数据库。

③，Oracle有表空间概念、Mysql没有。

④，Oracle可设置用户权限、访问权限、读写权限等，Mysql没有。

⑤，Oracle需要用户手动提交、Mysql默认自动提交。

⑥，Oracle全面、完整、稳定，对硬件要求高；Mysql使用cup和内存少，性能高。

⑦，Oracle使用许多安全功能，如用户名，密码，配置文件，本地身份证，外部身份验证，高级安全增强功能。Mysql使用三个参数来验证用户，即用户名、密码、位置；数据库认证上Mysql比Oracle认证更加容易。 
```

# Mysql和MariaDB区别

```shell
MariaDB数据库管理系统是Mysql的一个分支，目的是完全兼容Mysql，能够成为Mysql的代替品，运行速度更快。
```

# 关系型数据库与非关系型数据库的区别

```shell
①，关系型数据库
关系型数据库相当于一个目录，这个目录是存放数据的库。库里存放表，相当于文件。

优点：
1、遵循四大事务(原子性、一致性、隔离性、持续性)
2、支持sql语句，可用于表结构的复杂查询。

缺点：
1、读写性能差，海量的数据压力大
2、高并发性能差，传统关系型数据库而言，硬盘I/O是很大的瓶颈
3、固定表结构，灵活度稍欠                
Mysql是常用的关系型数据库。

②，非关系型数据库(Nosql、作为关系型数据库的补充)
非关系型数据是一种数据结构化存储方法的集合，可以是文档或者键值对等

优点：
1、灵活性：存储数据格式灵活可以是key,value形式、文档形式、图片形式等等，使用也灵活，应用场景广泛
2、高性能、速度快：nosql使用硬盘和内存，关系型数据库只能使用硬盘
3、高扩展性
4、成本低：开源

缺：
1、无标准查询语言、不提供sql支持
2、无事务处理能力
3、数据结构相对复杂，复杂查询方面稍欠
Redis是常用的非关系型数据库，且可持久化数据。

③，Mysql数据存储在磁盘中，redis数据存储在磁盘和内存中读写速度快。

④，Mysql端口号：3306、redis端口号：6379
```

# 数据库存储引擎(扩展)

```shell
①，数据库存储引擎

存储引擎是数据库底层软件组织，数据库管理系统(DBMS)使用存储引擎进行创建、查询、更新、删除数据。

②，innodb

支持事务，支持行锁定，对事务的完整性要求比较高(银行)，要求实现并发控制(售票)，适用于频繁更新，删除操作数据库。

③，myisam：较高的查询速度，不支持事务。

④，mermory：读写速度快，安全性不高，对表的大小有要求，支持锁表不支持行锁定。
```

# 事务要符合四个条件(ACID)

```shell
原子性：事务要么成功，要么撤回，不会结束到中间某个环节。

一致性：数据库以及事务永远保持一致性，数据库的完整性不被破坏，即写入的数据必须符合预设的规则。

隔离性：多个事务同时对数据库的数据进行修改时，事务与事务之间存在隔离性。你干你的，我干我的。

持续性：数据会永久存储在永久存储器里
```

# 数据类型

```shell
1、整型(int)：作用:用户年龄、游戏等级、经验值

2、浮点数类型(float)：作用:用户身高、体重、薪水

3、定点数类型：作用: 货币等精度高的数据

4、字符串类型

(char)固定字符串0~255、长度是固定的，插入数据的长度小于char的固定长度时，则用空格填充。

(varchar)可变长度字符串0~65535、长度是可变的，插入的数据是多长，就按多长来存储。

结合性能角度（char更快），节省磁盘空间角度（varchar更小），经常变化的字段用varchar，超过255字符的只能用varchar或者text

5、枚举类型enum：二选其一

6、日期类型：(year、date、time、datetime、datestamp) 
储存用户注册时间、文章发布时间、文章更新时间、员工入职时间
```

# Mysql备份

```
物理备份：完整备份、增量备份
逻辑备份：mysqldump工具备份
差异备份
```

# 完整备份

```shell
备份完整的数据库数据

优点：备份与恢复操作简单方便，恢复时一次恢复到位，恢复速度快

缺点：占用空间大，备份速度慢
```

# 增量备份

```shell
备份上一次备份到现在产生的新数据

优点：数据量小，占用空间小，备份速度快

缺点：恢复时间长，如中间某次的备份数据损坏，将导致数据的丢失
```

# Mysqldump备份工具原理及使用流程

```shell
原理：
mysqldump备份工具是mysql自带的命令工具，通过sql语句去实现数据的备份和恢复。

备份流程：
1、备份表：
mysqldump -u root -p123 warehouse1 t1 > /home/back/warehouse1.t1.bak

2、备份库：
mysqldump -uroot -p123 warehouse1 > /home/back/warehouse1.bak

3、备份所有库：
mysqldump -uroot -p123 -A > /home/back/allbase.bak

恢复流程：
1、恢复库(先在数据库创建一个新库)
mysql -uroot -p123 warehouse1 < /home/back/warehouse1.bak

2、恢复表
mysql> set sql_log_bin=0;   #停止binlog日志
Query OK, 0 rows affected (0.00 sec)
mysql> source /home/back/warehouse1.t1.bak
```



# 差异备份

```shell
只备份跟完整备份不一样的数据，占用空间会比增量备份大

恢复速度介于完整备份和增量备份之间
```

# 物理备份

```shell
热备 冷备 温备
```

# 备份方式

```shell
每周一次完整备份，平时每天增量备份

日志生命周期：前三十天热备，30-60天温备，60-90天冷备，超过=90天扔掉
```

# Mysql优化

```shell
1、安全方面：修改默认端口号，禁止root用户远程登录，对用户降权，以普通用户运行mysql

2、性能方面：升级硬件，内存、磁盘、优化sql语句（开启慢查询）、设置索引

3、参数变化：innodb的buffer参数调大，连接数调大、缓存的参数优化

4、架构方面：读写分离，一主多从，高可用、mysql的约束添加
```

# 主从复制原理

```shell
主机打开binlog日志，，从机通过io进程读取主机的binlog日志，并将其记录到从库的中继日志里面，sql线程读取中继日志，同步到自己的数据库，实现主从复制。
```

# 主从复制问题如何解决

```http
你在工作当中遇到过什么问题？如何去解决的？
```



```shell
1、查看error日志，排错

2、slave库，show slave status\G 定位io或sql线程
解决故障：

停止从同步
跳过一个事务(跳出出错的一步)
重新开启同步，查看同步状态

如果还不行，就将问题库名的数据，从主库导出，导入从库后，重新主从
配合keepalived做高可用
```

# 主从复制数据不一致如何解决

```http
你在工作当中遇到过什么问题？如何去解决的？
```



```shell
问题原因

①人为误操作在从节点写入数据造成主从binlog节点不同步

②mysql版本不一致，个别语法执行不成功，5.7可以创建用户并授权，8.0必须先创建用户才能授权

解决方法：先停止主从复制，跳过当前事务，再开启主从同步，手动创建用户并授权，保证主从数据一致

问题原因

③主节点允许传送的数据最大是10M，从节点允许传送的数据最大是5M，如果一个7M的数据发送，主节点成功，从节点失败，导致主从数据不一致

解决方法：在mysql配置文件中设置max_allowed_packet（允许的最大数据包）的大小，这也是mysql优化的其中一项
```

# 异步复制

```shell
MySQL默认的复制即是异步的，主库在执行完客户端提交的事务后会立即将结果返给给客户端，并不关心从库是否已经接收并处理。  
```

# 同步复制

```shell
指当主库执行完一个事务，所有的从库都执行了该事务才返回给客户端。因为需要等待所有从库执行完该事务才能返回，所以全同步复制的性能必然会收到严重的影响。
```

# 半同步复制

```shell
是介于同步复制与异步复制之间的一种，主库只需要等待至少一个从库节点收到并反馈事务即可，主库不需要等待所有从库给主库反馈。同时，这里只是一个收到的反馈，而不是已经完全完成并且提交的反馈，如此，节省了很多时间。
```

# 脏读

```shell
脏读就是修改一个数据，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据、
```

# 幻读

```shell
第一个事务对表中的数据进行了修改，修改表中的全部数据行。第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样
```

# 不可重复读

```shell
是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。因此称为是不可重复读 
```

# SQL定义了事务隔离级别分为四种

```shell
1、RU读未提交：可能出现脏读、不可重复读和幻读。

2、RC读已提交：可以避免脏读，但可能出现不可重复读和幻读。

3、RR可重复读：可以避免脏读和不可重复读，但可能出现幻读

4、可串行化：可以避免脏读、不可重复读和幻读，但是并发性极低，一般很少使用。

系统默认RR
```

# 数据库的一致性

```shell
就是多个节点中数据的值是一致的

强一致性：写入数据后，立马能读到最新的数据。

弱一致性：写入成功后，不承诺能立马读到最新的值，但在一定时间后能读到。
```

# Sql语句执行慢的原因？如何解决？

```
问题
1、索引不合理：数据量很大，没有合适的索引会造成数据库进行搜索数据，从而导致效率低下。
2、表的结构设计不合理：查询效率低
3、硬件问题：设备老化、内存小、I/O速度慢
4、网络延迟

解决：
1、优化、更新索引，加快sql语句执行效率
2、优化表结构，合理分配内存空间
3、加钱
```



# mysql脏数据是什么概念？

```
数据不在给定的范围内，对实际业务没有意义。数据的格式非法。
```



# mysql主从复制的方式有几种？

```
Gtid
1、master更新数据时，会在事务前产生GTID，一同记录到binlog日志中。
2、slave端的i/o线程将变更的binlog，写入到本地的relay log中。
3、sql线程从relay log中获取GTID，然后对比slave端的binlog是否有记录。
4、如果有记录，说明该GTID的事务已经执行，slave会忽略。
5、如果没有记录，slave就会从relay log中执行该GTID的事务，并记录到binlog。
```

![MySQL 主从模式采用GTID 的实践- 知乎](assets/Mysql/v2-3e95be8ed3f7eb9a644a897d3bfe50cb_1440w.webp)

```
Binlog
主机打开binlog日志，，从机通过io进程读取主机的binlog日志，并将其记录到从库的中继日志里面，sql线程读取中继日志，同步到自己的数据库，实现主从复制。
```



# 监控mysql都监控什么，都是怎么做的？

```
1、mysql进程状态和资源使用情况
2、mysql的连接数、端口、磁盘使用率

做法：
1、mysql服务端安装zabbix agent
2、配置监控项：mysql的连接数、端口、磁盘使用情况等
3、创建触发器：进行报警，比如说mysql端口掉了或者是连接数超过了一定的阈值会触发zabbix报警
4、创建图形：了解mysql各种性能的指标
```



# 公司有几台Mysql？配置什么样的？

```
10台mysql、2核四G、1T内存
```

